(()=>{"use strict";var e="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var t=new e(16);return e!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var r,o,n=function(e,t,r,o,n){var i,a=1/Math.tan(t/2);return e[0]=a/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=n&&n!==1/0?(i=1/(o-n),e[10]=(n+o)*i,e[14]=2*n*o*i):(e[10]=-1,e[14]=-2*o),e};function i(t,r,o){var n=new e(3);return n[0]=t,n[1]=r,n[2]=o,n}r=new e(3),e!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),function(e){e[e.SUCESS=0]="SUCESS",e[e.ERROR=1]="ERROR"}(o||(o={}));const a={meshName:"cube",vertexArray:new Float32Array([1,-1,1,1,1,0,1,1,1,1,-1,-1,1,1,0,0,1,1,0,1,-1,-1,-1,1,0,0,0,1,0,0,1,-1,-1,1,1,0,0,1,1,0,1,-1,1,1,1,0,1,1,1,1,-1,-1,-1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,0,1,1,-1,-1,1,1,0,0,1,0,0,1,1,-1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,-1,-1,1,1,0,0,1,0,0,-1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,-1,1,1,1,0,1,0,0,-1,1,-1,1,0,1,0,1,1,0,-1,1,1,1,0,1,1,1,1,1,1,1,-1,1,1,1,0,1,0,0,-1,-1,1,1,0,0,1,1,1,1,-1,1,1,1,0,1,1,1,0,1,-1,1,-1,1,0,1,0,1,0,0,-1,-1,-1,1,0,0,0,1,1,0,-1,-1,1,1,0,0,1,1,1,1,-1,1,-1,1,0,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,1,0,1,-1,-1,1,1,0,0,1,1,0,0,-1,-1,1,1,0,0,1,1,0,0,1,-1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,-1,-1,1,1,0,0,1,1,1,-1,-1,-1,1,0,0,0,1,0,1,-1,1,-1,1,0,1,0,1,0,0,1,1,-1,1,1,1,0,1,1,0,1,-1,-1,1,1,0,0,1,1,1,-1,1,-1,1,0,1,0,1,0,0]),vertexCount:36,vertexSize:40,colorOffset:16,uvOffset:32,positionOffset:0},s=new Float32Array([0,1,0,1,1,0,1,1,1,1,-1,-1,1,1,0,0,1,1,0,1,1,-1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,0,1,1,-1,-1,1,1,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,-1,-1,1,1,0,1,1,0,1,-1,-1,-1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,-1,-1,-1,1,0,1,1,1,0,1,-1,-1,1,1,0,1,0,1,0,0,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,1,0,1,1,1,0,1,1,-1,1,1,0,0,1,1,0,0,-1,-1,-1,1,0,0,1,1,0,0,1,-1,1,1,0,0,1,1,0,0,-1,-1,1,1,1,1,1,1,1,1]);var f=function(e,t,r,o){return new(r||(r=Promise))((function(n,i){function a(e){try{f(o.next(e))}catch(e){i(e)}}function s(e){try{f(o.throw(e))}catch(e){i(e)}}function f(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,s)}f((o=o.apply(e,t||[])).next())}))};const u={meshName:"pyramid",vertexArray:s,vertexCount:18,vertexSize:40,colorOffset:16,uvOffset:32,positionOffset:0},c=new class{constructor(e=40,t=0,r=16,o=32){this._meshes=new Map,this._vertexCount=0,this._vertexSize=e,this._positionOffset=t,this._colorOffset=r,this._uvOffset=o}get vertexSize(){return this._vertexSize}get positionOffset(){return this._positionOffset}get colorOffset(){return this._colorOffset}get uvOffset(){return this._uvOffset}get vertexCount(){return this._vertexCount}get(e){const t=this._meshes.get(e);if(!t)throw new Error("Cannot find mesh!");return t}add(e){if(this._meshes.has(e.meshName))throw new Error("Mesh already in map.");if(this.vertexSize!=e.vertexSize)throw new Error("Cannot add mesh with different vertex size to the ");if(this.positionOffset!=e.positionOffset||this.colorOffset!=e.colorOffset||this.uvOffset!=e.uvOffset)throw new Error("Cannot add mesh with different offsets.");let t=this.vertexCount;this.vertexCount>0&&(t-=1),this._meshes.set(e.meshName,{mesh:e,offset:t}),console.log(this.vertexCount),this._vertexCount+=e.vertexCount}remove(e){this._meshes.has(e.meshName)&&(this._vertexCount-=e.vertexCount,this._meshes.delete(e.meshName))}forEach(e,t){this._meshes.forEach(e,t)}},h=[],l=[],d=e=>(h.push(e),o.SUCESS),v=e=>{try{return c.add(e),o.SUCESS}catch(e){return console.log(e),o.ERROR}};console.log(v(a)),v(u);const m=(e,t,r,o)=>e.createBindGroup({layout:t.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r,offset:256*o,size:64}}]}),p=({canvas:e,pageState:r})=>f(void 0,void 0,void 0,(function*(){const o=yield function(e,t,r=!1,o=!1){return f(this,void 0,void 0,(function*(){const n=yield e.requestAdapter({powerPreference:t,forceFallbackAdapter:r});return(null==n?void 0:n.isFallbackAdapter)&&!0===o?null:n}))}(navigator.gpu,"high-performance",!1,!0),i=yield null==o?void 0:o.requestAdapterInfo();if(console.log(null==i?void 0:i.vendor),console.log(null==o?void 0:o.isFallbackAdapter),null==o)throw new Error("Could not find adapter");const a=yield o.requestDevice();if(!r.active)return;const s=e.getContext("webgpu"),u=window.devicePixelRatio||1,d=[e.clientWidth*u,e.clientHeight*u],v=navigator.gpu.getPreferredCanvasFormat();s.configure({device:a,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:v,alphaMode:"opaque"});const p=a.createBuffer({size:c.vertexSize*c.vertexCount,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});let g=new Float32Array(p.getMappedRange());c.forEach((({mesh:e,offset:t})=>{g.set(e.vertexArray,c.vertexSize/4*t)})),p.unmap();const x=a.createRenderPipeline({layout:"auto",vertex:{module:a.createShaderModule({code:"struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n}\n@binding(0) @group(0) var<uniform> uniforms : Uniforms;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn main(\n  @location(0) position : vec4<f32>,\n  @location(1) uv : vec2<f32>\n) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = uniforms.modelViewProjectionMatrix * position;\n  output.fragUV = uv;\n  output.fragPosition = 0.5 * (position + vec4(1.0, 1.0, 1.0, 1.0));\n  return output;\n}\n"}),entryPoint:"main",buffers:[{arrayStride:c.vertexSize,attributes:[{shaderLocation:0,offset:c.positionOffset,format:"float32x4"},{shaderLocation:1,offset:c.uvOffset,format:"float32x2"}]}]},fragment:{module:a.createShaderModule({code:"@fragment\nfn main(\n  @location(0) fragUV: vec2<f32>,\n  @location(1) fragPosition: vec4<f32>\n) -> @location(0) vec4<f32> {\n  return fragPosition;\n}\n"}),entryPoint:"main",targets:[{format:v}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}}),w=a.createTexture({size:d,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),y=a.createBuffer({size:512,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});for(let e=0;e<h.length;e++)l.push(m(a,x,y,e));const O={colorAttachments:[{view:void 0,resolveTarget:void 0,clearValue:{r:.5,g:.5,b:.5,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:w.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},C=e.width/e.height,S=t();n(S,2*Math.PI/5,C,1,100),requestAnimationFrame((function e(){if(!r.active)return;for(let e of h)e.onUpdate();for(let e=0;e<h.length;e++){const t=h[e].transform,r=256*e;console.log("Offset: "+r+"\n Name:"+h[e].meshName+"\n Matrix: "+t),a.queue.writeBuffer(y,r,t.buffer,t.byteOffset,t.byteLength)}O.colorAttachments[0].view=s.getCurrentTexture().createView();const t=a.createCommandEncoder(),o=t.beginRenderPass(O);o.setPipeline(x),o.setVertexBuffer(0,p);for(let e=0;e<h.length;e++){const{mesh:t,offset:r}=c.get(h[e].meshName);o.setBindGroup(0,l[e]),o.draw(t.vertexCount,1,r,0)}o.end(),a.queue.submit([t.finish()]),requestAnimationFrame(e)}))}));if((()=>{const e=navigator.gpu,t=document.getElementById("gpu-check");return e?(t.textContent="WebGPU Enabled!",!0):(t.textContent="Current browser does not support WebGPU!",!1)})()){console.log("Starting Bigworld...");const g=(()=>{const e=document.createElement("canvas"),t=document.getElementById("checker-div");return document.body.insertBefore(e,t),e.id="web-gpu-context",e.width=640,e.height=480,null==t||t.remove(),e})(),x=g.width/g.height,w=t();function y(e=0){const r=t();!function(e,t,r){var o,n,i,a,s,f,u,c,h,l,d,v,m=r[0],p=r[1],g=r[2];t===e?(e[12]=t[0]*m+t[4]*p+t[8]*g+t[12],e[13]=t[1]*m+t[5]*p+t[9]*g+t[13],e[14]=t[2]*m+t[6]*p+t[10]*g+t[14],e[15]=t[3]*m+t[7]*p+t[11]*g+t[15]):(o=t[0],n=t[1],i=t[2],a=t[3],s=t[4],f=t[5],u=t[6],c=t[7],h=t[8],l=t[9],d=t[10],v=t[11],e[0]=o,e[1]=n,e[2]=i,e[3]=a,e[4]=s,e[5]=f,e[6]=u,e[7]=c,e[8]=h,e[9]=l,e[10]=d,e[11]=v,e[12]=o*m+s*p+h*g+t[12],e[13]=n*m+f*p+l*g+t[13],e[14]=i*m+u*p+d*g+t[14],e[15]=a*m+c*p+v*g+t[15])}(r,r,i(e,0,-4));const o=Date.now()/1e3;!function(e,t,r,o){var n,i,a,s,f,u,c,h,l,d,v,m,p,g,x,w,y,O,C,S,P,E,U,b,A=o[0],M=o[1],_=o[2],R=Math.hypot(A,M,_);R<1e-6||(A*=R=1/R,M*=R,_*=R,n=Math.sin(r),a=1-(i=Math.cos(r)),s=t[0],f=t[1],u=t[2],c=t[3],h=t[4],l=t[5],d=t[6],v=t[7],m=t[8],p=t[9],g=t[10],x=t[11],w=A*A*a+i,y=M*A*a+_*n,O=_*A*a-M*n,C=A*M*a-_*n,S=M*M*a+i,P=_*M*a+A*n,E=A*_*a+M*n,U=M*_*a-A*n,b=_*_*a+i,e[0]=s*w+h*y+m*O,e[1]=f*w+l*y+p*O,e[2]=u*w+d*y+g*O,e[3]=c*w+v*y+x*O,e[4]=s*C+h*S+m*P,e[5]=f*C+l*S+p*P,e[6]=u*C+d*S+g*P,e[7]=c*C+v*S+x*P,e[8]=s*E+h*U+m*b,e[9]=f*E+l*U+p*b,e[10]=u*E+d*U+g*b,e[11]=c*E+v*U+x*b,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]))}(r,r,1,i(Math.sin(o),Math.cos(o),0));const n=t();return function(e,t,r){var o=t[0],n=t[1],i=t[2],a=t[3],s=t[4],f=t[5],u=t[6],c=t[7],h=t[8],l=t[9],d=t[10],v=t[11],m=t[12],p=t[13],g=t[14],x=t[15],w=r[0],y=r[1],O=r[2],C=r[3];e[0]=w*o+y*s+O*h+C*m,e[1]=w*n+y*f+O*l+C*p,e[2]=w*i+y*u+O*d+C*g,e[3]=w*a+y*c+O*v+C*x,w=r[4],y=r[5],O=r[6],C=r[7],e[4]=w*o+y*s+O*h+C*m,e[5]=w*n+y*f+O*l+C*p,e[6]=w*i+y*u+O*d+C*g,e[7]=w*a+y*c+O*v+C*x,w=r[8],y=r[9],O=r[10],C=r[11],e[8]=w*o+y*s+O*h+C*m,e[9]=w*n+y*f+O*l+C*p,e[10]=w*i+y*u+O*d+C*g,e[11]=w*a+y*c+O*v+C*x,w=r[12],y=r[13],O=r[14],C=r[15],e[12]=w*o+y*s+O*h+C*m,e[13]=w*n+y*f+O*l+C*p,e[14]=w*i+y*u+O*d+C*g,e[15]=w*a+y*c+O*v+C*x}(n,w,r),n}n(w,2*Math.PI/5,x,1,100),t(),t();class O{constructor(){this.meshName="cube",this.transform=t()}onUpdate(){this.transform=y(-2)}}class C{constructor(){this.meshName="pyramid",this.transform=t()}onUpdate(){this.transform=y(2)}}d(new O),d(new C),p({canvas:g,pageState:{active:!0}})}})();
//# sourceMappingURL=main.bundle.js.map