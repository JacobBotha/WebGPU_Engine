(()=>{"use strict";var e="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var t=new e(16);return e!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var r,o=function(e,t,r,o,n){var s,i=1/Math.tan(t/2);return e[0]=i/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=n&&n!==1/0?(s=1/(o-n),e[10]=(n+o)*s,e[14]=2*n*o*s):(e[10]=-1,e[14]=-2*o),e};function n(){var t=new e(3);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function s(t,r,o){var n=new e(3);return n[0]=t,n[1]=r,n[2]=o,n}n(),function(e){e[e.SUCESS=0]="SUCESS",e[e.ERROR=1]="ERROR"}(r||(r={}));const i={meshName:"cube",vertexArray:new Float32Array([1,-1,1,1,1,0,1,1,1,1,-1,-1,1,1,0,0,1,1,0,1,-1,-1,-1,1,0,0,0,1,0,0,1,-1,-1,1,1,0,0,1,1,0,1,-1,1,1,1,0,1,1,1,1,-1,-1,-1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,0,1,1,-1,-1,1,1,0,0,1,0,0,1,1,-1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,-1,-1,1,1,0,0,1,0,0,-1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,-1,1,1,1,0,1,0,0,-1,1,-1,1,0,1,0,1,1,0,-1,1,1,1,0,1,1,1,1,1,1,1,-1,1,1,1,0,1,0,0,-1,-1,1,1,0,0,1,1,1,1,-1,1,1,1,0,1,1,1,0,1,-1,1,-1,1,0,1,0,1,0,0,-1,-1,-1,1,0,0,0,1,1,0,-1,-1,1,1,0,0,1,1,1,1,-1,1,-1,1,0,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,1,0,1,-1,-1,1,1,0,0,1,1,0,0,-1,-1,1,1,0,0,1,1,0,0,1,-1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,-1,-1,1,1,0,0,1,1,1,-1,-1,-1,1,0,0,0,1,0,1,-1,1,-1,1,0,1,0,1,0,0,1,1,-1,1,1,1,0,1,1,0,1,-1,-1,1,1,0,0,1,1,1,-1,1,-1,1,0,1,0,1,0,0]),vertexCount:36,vertexSize:40,colorOffset:16,uvOffset:32,positionOffset:0},a=new Float32Array([0,1,0,1,1,0,1,1,1,1,-1,-1,1,1,0,0,1,1,0,1,1,-1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,0,1,1,-1,-1,1,1,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,-1,-1,1,1,0,1,1,0,1,-1,-1,-1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,-1,-1,-1,1,0,1,1,1,0,1,-1,-1,1,1,0,1,0,1,0,0,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,1,0,1,1,1,0,1,1,-1,1,1,0,0,1,1,0,0,-1,-1,-1,1,0,0,1,1,0,0,1,-1,1,1,0,0,1,1,0,0,-1,-1,1,1,1,1,1,1,1,1]);var f=function(e,t,r,o){return new(r||(r=Promise))((function(n,s){function i(e){try{f(o.next(e))}catch(e){s(e)}}function a(e){try{f(o.throw(e))}catch(e){s(e)}}function f(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(i,a)}f((o=o.apply(e,t||[])).next())}))};const u={meshName:"pyramid",vertexArray:a,vertexCount:18,vertexSize:40,colorOffset:16,uvOffset:32,positionOffset:0},c=new class{constructor(e=40,t=0,r=16,o=32){this._meshes=new Map,this._vertexCount=0,this._vertexSize=e,this._positionOffset=t,this._colorOffset=r,this._uvOffset=o}get vertexSize(){return this._vertexSize}get positionOffset(){return this._positionOffset}get colorOffset(){return this._colorOffset}get uvOffset(){return this._uvOffset}get vertexCount(){return this._vertexCount}get(e){const t=this._meshes.get(e);if(!t)throw new Error("Cannot find mesh!");return t}add(e){if(this._meshes.has(e.meshName))throw new Error("Mesh already in map.");if(this.vertexSize!=e.vertexSize)throw new Error("Cannot add mesh with different vertex size to the ");if(this.positionOffset!=e.positionOffset||this.colorOffset!=e.colorOffset||this.uvOffset!=e.uvOffset)throw new Error("Cannot add mesh with different offsets.");let t=this.vertexCount;this.vertexCount>0&&(t-=1),this._meshes.set(e.meshName,{mesh:e,offset:t}),console.log(this.vertexCount),this._vertexCount+=e.vertexCount}remove(e){this._meshes.has(e.meshName)&&(this._vertexCount-=e.vertexCount,this._meshes.delete(e.meshName))}forEach(e,t){this._meshes.forEach(e,t)}},h=[],l=[],d=e=>(h.push(e),r.SUCESS),v=e=>{try{return c.add(e),r.SUCESS}catch(e){return console.log(e),r.ERROR}};console.log(v(i)),v(u);const m=(e,t,r,o)=>e.createBindGroup({layout:t.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r,offset:256*o,size:64}}]}),p=({canvas:e,pageState:r})=>f(void 0,void 0,void 0,(function*(){const n=yield function(e,t,r=!1,o=!1){return f(this,void 0,void 0,(function*(){const n=yield e.requestAdapter({powerPreference:t,forceFallbackAdapter:r});return(null==n?void 0:n.isFallbackAdapter)&&!0===o?null:n}))}(navigator.gpu,"high-performance",!1,!0),s=yield null==n?void 0:n.requestAdapterInfo();if(console.log(null==s?void 0:s.vendor),console.log(null==n?void 0:n.isFallbackAdapter),null==n)throw new Error("Could not find adapter");const i=yield n.requestDevice();if(!r.active)return;const a=e.getContext("webgpu"),u=window.devicePixelRatio||1,d=[e.clientWidth*u,e.clientHeight*u],v=navigator.gpu.getPreferredCanvasFormat();a.configure({device:i,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:v,alphaMode:"opaque"});const p=i.createBuffer({size:c.vertexSize*c.vertexCount,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});let g=new Float32Array(p.getMappedRange());c.forEach((({mesh:e,offset:t})=>{g.set(e.vertexArray,c.vertexSize/4*t)})),p.unmap();const x=i.createRenderPipeline({layout:"auto",vertex:{module:i.createShaderModule({code:"struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n}\n@binding(0) @group(0) var<uniform> uniforms : Uniforms;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn main(\n  @location(0) position : vec4<f32>,\n  @location(1) uv : vec2<f32>\n) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = uniforms.modelViewProjectionMatrix * position;\n  output.fragUV = uv;\n  output.fragPosition = 0.5 * (position + vec4(1.0, 1.0, 1.0, 1.0));\n  return output;\n}\n"}),entryPoint:"main",buffers:[{arrayStride:c.vertexSize,attributes:[{shaderLocation:0,offset:c.positionOffset,format:"float32x4"},{shaderLocation:1,offset:c.uvOffset,format:"float32x2"}]}]},fragment:{module:i.createShaderModule({code:"@fragment\nfn main(\n  @location(0) fragUV: vec2<f32>,\n  @location(1) fragPosition: vec4<f32>\n) -> @location(0) vec4<f32> {\n  return fragPosition;\n}\n"}),entryPoint:"main",targets:[{format:v}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}}),w=i.createTexture({size:d,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),y=256*h.length,P=i.createBuffer({size:y,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});for(let e=0;e<h.length;e++)l.push(m(i,x,P,e));const C={colorAttachments:[{view:void 0,resolveTarget:void 0,clearValue:{r:.5,g:.5,b:.5,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:w.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},O=e.width/e.height,S=t();o(S,2*Math.PI/5,O,1,100),requestAnimationFrame((function e(){if(!r.active)return;for(let e of h)e.onUpdate();for(let e=0;e<h.length;e++){const t=h[e].transform,r=256*e;i.queue.writeBuffer(P,r,t.buffer,t.byteOffset,t.byteLength)}C.colorAttachments[0].view=a.getCurrentTexture().createView();const t=i.createCommandEncoder(),o=t.beginRenderPass(C);o.setPipeline(x),o.setVertexBuffer(0,p);for(let e=0;e<h.length;e++){const{mesh:t,offset:r}=c.get(h[e].meshName);o.setBindGroup(0,l[e]),o.draw(t.vertexCount,1,r,0)}o.end(),i.queue.submit([t.finish()]),requestAnimationFrame(e)}))}));if((()=>{const e=navigator.gpu,t=document.getElementById("gpu-check");return e?(t.textContent="WebGPU Enabled!",!0):(t.textContent="Current browser does not support WebGPU!",!1)})()){console.log("Starting Bigworld...");const g=(()=>{const e=document.createElement("canvas"),t=document.getElementById("checker-div");return document.body.insertBefore(e,t),e.id="web-gpu-context",e.width=640,e.height=480,null==t||t.remove(),e})(),x=g.width/g.height,w=t();function y(e=0,r=0,o=0){const n=t();var i,a,f,u,c,h,l,d,v,m,p,g,x,y,P,C,O,S;i=n,a=n,C=(f=s(e,r,o))[0],O=f[1],S=f[2],a===i?(i[12]=a[0]*C+a[4]*O+a[8]*S+a[12],i[13]=a[1]*C+a[5]*O+a[9]*S+a[13],i[14]=a[2]*C+a[6]*O+a[10]*S+a[14],i[15]=a[3]*C+a[7]*O+a[11]*S+a[15]):(u=a[0],c=a[1],h=a[2],l=a[3],d=a[4],v=a[5],m=a[6],p=a[7],g=a[8],x=a[9],y=a[10],P=a[11],i[0]=u,i[1]=c,i[2]=h,i[3]=l,i[4]=d,i[5]=v,i[6]=m,i[7]=p,i[8]=g,i[9]=x,i[10]=y,i[11]=P,i[12]=u*C+d*O+g*S+a[12],i[13]=c*C+v*O+x*S+a[13],i[14]=h*C+m*O+y*S+a[14],i[15]=l*C+p*O+P*S+a[15]);const E=Date.now()/1e3;!function(e,t,r,o){var n,s,i,a,f,u,c,h,l,d,v,m,p,g,x,w,y,P,C,O,S,E,U,b,A=o[0],M=o[1],_=o[2],R=Math.hypot(A,M,_);R<1e-6||(A*=R=1/R,M*=R,_*=R,n=Math.sin(1),i=1-(s=Math.cos(1)),a=t[0],f=t[1],u=t[2],c=t[3],h=t[4],l=t[5],d=t[6],v=t[7],m=t[8],p=t[9],g=t[10],x=t[11],w=A*A*i+s,y=M*A*i+_*n,P=_*A*i-M*n,C=A*M*i-_*n,O=M*M*i+s,S=_*M*i+A*n,E=A*_*i+M*n,U=M*_*i-A*n,b=_*_*i+s,e[0]=a*w+h*y+m*P,e[1]=f*w+l*y+p*P,e[2]=u*w+d*y+g*P,e[3]=c*w+v*y+x*P,e[4]=a*C+h*O+m*S,e[5]=f*C+l*O+p*S,e[6]=u*C+d*O+g*S,e[7]=c*C+v*O+x*S,e[8]=a*E+h*U+m*b,e[9]=f*E+l*U+p*b,e[10]=u*E+d*U+g*b,e[11]=c*E+v*U+x*b,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]))}(n,n,0,s(Math.sin(E),Math.cos(E),0));const U=t();return function(e,t,r){var o=t[0],n=t[1],s=t[2],i=t[3],a=t[4],f=t[5],u=t[6],c=t[7],h=t[8],l=t[9],d=t[10],v=t[11],m=t[12],p=t[13],g=t[14],x=t[15],w=r[0],y=r[1],P=r[2],C=r[3];e[0]=w*o+y*a+P*h+C*m,e[1]=w*n+y*f+P*l+C*p,e[2]=w*s+y*u+P*d+C*g,e[3]=w*i+y*c+P*v+C*x,w=r[4],y=r[5],P=r[6],C=r[7],e[4]=w*o+y*a+P*h+C*m,e[5]=w*n+y*f+P*l+C*p,e[6]=w*s+y*u+P*d+C*g,e[7]=w*i+y*c+P*v+C*x,w=r[8],y=r[9],P=r[10],C=r[11],e[8]=w*o+y*a+P*h+C*m,e[9]=w*n+y*f+P*l+C*p,e[10]=w*s+y*u+P*d+C*g,e[11]=w*i+y*c+P*v+C*x,w=r[12],y=r[13],P=r[14],C=r[15],e[12]=w*o+y*a+P*h+C*m,e[13]=w*n+y*f+P*l+C*p,e[14]=w*s+y*u+P*d+C*g,e[15]=w*i+y*c+P*v+C*x}(U,w,n),U}o(w,2*Math.PI/5,x,1,100),t(),t();class P{constructor(e=n()){this.meshName="cube",this.transform=t(),this.startPos=e}onUpdate(){this.transform=y(this.startPos[0],this.startPos[1],this.startPos[2])}}class C{constructor(e=n()){this.meshName="pyramid",this.transform=t(),this.startPos=e}onUpdate(){this.transform=y(this.startPos[0],this.startPos[1],this.startPos[2])}}for(let O=1;O<=20;O++)d(new P(s(-2,-1,-4*O))),d(new C(s(2,-1,-4*O)));p({canvas:g,pageState:{active:!0}})}})();
//# sourceMappingURL=main.bundle.js.map