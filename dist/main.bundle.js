(()=>{"use strict";var e;!function(e){e[e.SUCESS=0]="SUCESS",e[e.ERROR=1]="ERROR"}(e||(e={}));const t={meshName:"cube",vertexArray:new Float32Array([1,-1,1,1,1,0,1,1,1,1,-1,-1,1,1,0,0,1,1,0,1,-1,-1,-1,1,0,0,0,1,0,0,1,-1,-1,1,1,0,0,1,1,0,1,-1,1,1,1,0,1,1,1,1,-1,-1,-1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,0,1,1,-1,-1,1,1,0,0,1,0,0,1,1,-1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,-1,-1,1,1,0,0,1,0,0,-1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,-1,1,1,1,0,1,0,0,-1,1,-1,1,0,1,0,1,1,0,-1,1,1,1,0,1,1,1,1,1,1,1,-1,1,1,1,0,1,0,0,-1,-1,1,1,0,0,1,1,1,1,-1,1,1,1,0,1,1,1,0,1,-1,1,-1,1,0,1,0,1,0,0,-1,-1,-1,1,0,0,0,1,1,0,-1,-1,1,1,0,0,1,1,1,1,-1,1,-1,1,0,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,1,0,1,-1,-1,1,1,0,0,1,1,0,0,-1,-1,1,1,0,0,1,1,0,0,1,-1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,-1,-1,1,1,0,0,1,1,1,-1,-1,-1,1,0,0,0,1,0,1,-1,1,-1,1,0,1,0,1,0,0,1,1,-1,1,1,1,0,1,1,0,1,-1,-1,1,1,0,0,1,1,1,-1,1,-1,1,0,1,0,1,0,0]),vertexCount:36,vertexSize:40,colorOffset:16,uvOffset:32,positionOffset:0};var r="undefined"!=typeof Float32Array?Float32Array:Array;function o(){var e=new r(16);return r!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var n;function i(e,t,o){var n=new r(3);return n[0]=e,n[1]=t,n[2]=o,n}n=new r(3),r!=Float32Array&&(n[0]=0,n[1]=0,n[2]=0);const a=new Float32Array([0,1,0,1,1,0,1,1,1,1,-1,-1,1,1,0,0,1,1,0,1,1,-1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,0,1,1,-1,-1,1,1,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,-1,-1,1,1,0,1,1,0,1,-1,-1,-1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,-1,-1,-1,1,0,1,1,1,0,1,-1,-1,1,1,0,1,0,1,0,0,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,1,0,1,1,1,0,1,1,-1,1,1,0,0,1,1,0,0,-1,-1,-1,1,0,0,1,1,0,0,1,-1,1,1,0,0,1,1,0,0,-1,-1,1,1,1,1,1,1,1,1]);var s=function(e,t,r,o){return new(r||(r=Promise))((function(n,i){function a(e){try{f(o.next(e))}catch(e){i(e)}}function s(e){try{f(o.throw(e))}catch(e){i(e)}}function f(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,s)}f((o=o.apply(e,t||[])).next())}))};const f={meshName:"pyramid",vertexArray:a,vertexCount:18,vertexSize:40,colorOffset:16,uvOffset:32,positionOffset:0},u=new class{constructor(e=40,t=0,r=16,o=32){this._meshes=new Map,this._vertexCount=0,this._vertexSize=e,this._positionOffset=t,this._colorOffset=r,this._uvOffset=o}get vertexSize(){return this._vertexSize}get positionOffset(){return this._positionOffset}get colorOffset(){return this._colorOffset}get uvOffset(){return this._uvOffset}get vertexCount(){return this._vertexCount}get(e){const t=this._meshes.get(e);if(!t)throw new Error("Cannot find mesh!");return t}add(e){if(this._meshes.has(e.meshName))throw new Error("Mesh already in map.");if(this.vertexSize!=e.vertexSize)throw new Error("Cannot add mesh with different vertex size to the ");if(this.positionOffset!=e.positionOffset||this.colorOffset!=e.colorOffset||this.uvOffset!=e.uvOffset)throw new Error("Cannot add mesh with different offsets.");let t=this.vertexCount;this.vertexCount>0&&(t-=1),this._meshes.set(e.meshName,{mesh:e,offset:t}),console.log(this.vertexCount),this._vertexCount+=e.vertexCount}remove(e){this._meshes.has(e.meshName)&&(this._vertexCount-=e.vertexCount,this._meshes.delete(e.meshName))}forEach(e,t){this._meshes.forEach(e,t)}},c=[],h=[],l=t=>(c.push(t),e.SUCESS),d=t=>{try{return u.add(t),e.SUCESS}catch(t){return console.log(t),e.ERROR}};console.log(d(t)),d(f),l({meshName:"pyramid",transform:o()}),l({meshName:"cube",transform:o()});const v=(e,t,r,o)=>e.createBindGroup({layout:t.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r,offset:256*o,size:64}}]}),m=({canvas:e,pageState:t})=>s(void 0,void 0,void 0,(function*(){const r=yield function(e,t,r=!1,o=!1){return s(this,void 0,void 0,(function*(){const n=yield e.requestAdapter({powerPreference:t,forceFallbackAdapter:r});return(null==n?void 0:n.isFallbackAdapter)&&!0===o?null:n}))}(navigator.gpu,"high-performance",!1,!0),n=yield null==r?void 0:r.requestAdapterInfo();if(console.log(null==n?void 0:n.vendor),console.log(null==r?void 0:r.isFallbackAdapter),null==r)throw new Error("Could not find adapter");const a=yield r.requestDevice();if(!t.active)return;const f=e.getContext("webgpu"),l=window.devicePixelRatio||1,d=[e.clientWidth*l,e.clientHeight*l],m=navigator.gpu.getPreferredCanvasFormat();f.configure({device:a,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:m,alphaMode:"opaque"});const p=a.createBuffer({size:u.vertexSize*u.vertexCount,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});let g=new Float32Array(p.getMappedRange());u.forEach((({mesh:e,offset:t})=>{g.set(e.vertexArray,u.vertexSize/4*t)})),console.log(g),p.unmap();const x=a.createRenderPipeline({layout:"auto",vertex:{module:a.createShaderModule({code:"struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n}\n@binding(0) @group(0) var<uniform> uniforms : Uniforms;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn main(\n  @location(0) position : vec4<f32>,\n  @location(1) uv : vec2<f32>\n) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = uniforms.modelViewProjectionMatrix * position;\n  output.fragUV = uv;\n  output.fragPosition = 0.5 * (position + vec4(1.0, 1.0, 1.0, 1.0));\n  return output;\n}\n"}),entryPoint:"main",buffers:[{arrayStride:u.vertexSize,attributes:[{shaderLocation:0,offset:u.positionOffset,format:"float32x4"},{shaderLocation:1,offset:u.uvOffset,format:"float32x2"}]}]},fragment:{module:a.createShaderModule({code:"@fragment\nfn main(\n  @location(0) fragUV: vec2<f32>,\n  @location(1) fragPosition: vec4<f32>\n) -> @location(0) vec4<f32> {\n  return fragPosition;\n}\n"}),entryPoint:"main",targets:[{format:m}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}}),w=a.createTexture({size:d,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),y=a.createBuffer({size:512,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});for(let e=0;e<c.length;e++)h.push(v(a,x,y,e));const O={colorAttachments:[{view:void 0,resolveTarget:void 0,clearValue:{r:.5,g:.5,b:.5,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:w.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},C=e.width/e.height,S=o();function b(e=0){const t=o();!function(e,t,r){var o,n,i,a,s,f,u,c,h,l,d,v,m=r[0],p=r[1],g=r[2];t===e?(e[12]=t[0]*m+t[4]*p+t[8]*g+t[12],e[13]=t[1]*m+t[5]*p+t[9]*g+t[13],e[14]=t[2]*m+t[6]*p+t[10]*g+t[14],e[15]=t[3]*m+t[7]*p+t[11]*g+t[15]):(o=t[0],n=t[1],i=t[2],a=t[3],s=t[4],f=t[5],u=t[6],c=t[7],h=t[8],l=t[9],d=t[10],v=t[11],e[0]=o,e[1]=n,e[2]=i,e[3]=a,e[4]=s,e[5]=f,e[6]=u,e[7]=c,e[8]=h,e[9]=l,e[10]=d,e[11]=v,e[12]=o*m+s*p+h*g+t[12],e[13]=n*m+f*p+l*g+t[13],e[14]=i*m+u*p+d*g+t[14],e[15]=a*m+c*p+v*g+t[15])}(t,t,i(e,0,-4));const r=Date.now()/1e3;!function(e,t,r,o){var n,i,a,s,f,u,c,h,l,d,v,m,p,g,x,w,y,O,C,S,b,E,P,A,M=o[0],U=o[1],_=o[2],R=Math.hypot(M,U,_);R<1e-6||(M*=R=1/R,U*=R,_*=R,n=Math.sin(1),a=1-(i=Math.cos(1)),s=t[0],f=t[1],u=t[2],c=t[3],h=t[4],l=t[5],d=t[6],v=t[7],m=t[8],p=t[9],g=t[10],x=t[11],w=M*M*a+i,y=U*M*a+_*n,O=_*M*a-U*n,C=M*U*a-_*n,S=U*U*a+i,b=_*U*a+M*n,E=M*_*a+U*n,P=U*_*a-M*n,A=_*_*a+i,e[0]=s*w+h*y+m*O,e[1]=f*w+l*y+p*O,e[2]=u*w+d*y+g*O,e[3]=c*w+v*y+x*O,e[4]=s*C+h*S+m*b,e[5]=f*C+l*S+p*b,e[6]=u*C+d*S+g*b,e[7]=c*C+v*S+x*b,e[8]=s*E+h*P+m*A,e[9]=f*E+l*P+p*A,e[10]=u*E+d*P+g*A,e[11]=c*E+v*P+x*A,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]))}(t,t,0,i(Math.sin(r),Math.cos(r),0));const n=o();return function(e,t,r){var o=t[0],n=t[1],i=t[2],a=t[3],s=t[4],f=t[5],u=t[6],c=t[7],h=t[8],l=t[9],d=t[10],v=t[11],m=t[12],p=t[13],g=t[14],x=t[15],w=r[0],y=r[1],O=r[2],C=r[3];e[0]=w*o+y*s+O*h+C*m,e[1]=w*n+y*f+O*l+C*p,e[2]=w*i+y*u+O*d+C*g,e[3]=w*a+y*c+O*v+C*x,w=r[4],y=r[5],O=r[6],C=r[7],e[4]=w*o+y*s+O*h+C*m,e[5]=w*n+y*f+O*l+C*p,e[6]=w*i+y*u+O*d+C*g,e[7]=w*a+y*c+O*v+C*x,w=r[8],y=r[9],O=r[10],C=r[11],e[8]=w*o+y*s+O*h+C*m,e[9]=w*n+y*f+O*l+C*p,e[10]=w*i+y*u+O*d+C*g,e[11]=w*a+y*c+O*v+C*x,w=r[12],y=r[13],O=r[14],C=r[15],e[12]=w*o+y*s+O*h+C*m,e[13]=w*n+y*f+O*l+C*p,e[14]=w*i+y*u+O*d+C*g,e[15]=w*a+y*c+O*v+C*x}(n,S,t),n}(function(e,t,r,o,n){var i,a=1/Math.tan(t/2);e[0]=a/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=n&&n!==1/0?(i=1/(o-n),e[10]=(n+o)*i,e[14]=2*n*o*i):(e[10]=-1,e[14]=-2*o)})(S,2*Math.PI/5,C,1,100),requestAnimationFrame((function e(){if(!t.active)return;const r=b(2);a.queue.writeBuffer(y,0,r.buffer,r.byteOffset,r.byteLength);const o=b(-2);a.queue.writeBuffer(y,256,o.buffer,o.byteOffset,o.byteLength),O.colorAttachments[0].view=f.getCurrentTexture().createView();const n=a.createCommandEncoder(),i=n.beginRenderPass(O);i.setPipeline(x),i.setVertexBuffer(0,p);for(let e=0;e<c.length;e++){const{mesh:t,offset:r}=u.get(c[e].meshName);i.setBindGroup(0,h[e]),i.draw(t.vertexCount,1,r,0)}i.end(),a.queue.submit([n.finish()]),requestAnimationFrame(e)}))}));(()=>{const e=navigator.gpu,t=document.getElementById("gpu-check");return e?(t.textContent="WebGPU Enabled!",!0):(t.textContent="Current browser does not support WebGPU!",!1)})()&&(console.log("Starting Bigworld..."),m({canvas:(()=>{const e=document.createElement("canvas"),t=document.getElementById("checker-div");return document.body.insertBefore(e,t),e.id="web-gpu-context",e.width=640,e.height=480,null==t||t.remove(),e})(),pageState:{active:!0}}))})();
//# sourceMappingURL=main.bundle.js.map